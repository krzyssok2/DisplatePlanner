@page "/planner"

@inject HttpClient HttpClient
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject IJSRuntime JsRuntime
@inject IHistoryService HistoryService

@using Blazored.LocalStorage
@using DisplatePlanner.Enums
@using DisplatePlanner.Interfaces
@using DisplatePlanner.Models
@using DisplatePlanner.Services
@using Microsoft.AspNetCore.Components.Web
@using System.Linq

<div class="main-container">
    <div oncontextmenu="return false;" class="grid" id="grid" tabindex="0"
    @onkeydown="OnKeyDown" @onkeydown:preventDefault
    @onwheel="OnZoom"
    @onmousemove="OnMouseMove"
    @onmouseup="OnMouseUp"
    @onmousedown="OnMouseDown" autofocus="true">
        @foreach (var rect in plates)
        {
            <div class="Plate @((selectedPlates.Contains(rect)) ? "selected" : "")"
            style="width: @($"{rect.Width * zoomLevel}px");
                        height: @($"{rect.Height * zoomLevel}px");
                        top: @($"{rect.Y * zoomLevel}px");
                        left: @($"{rect.X * zoomLevel}px");"
            @onclick="(e) => SelectAPlate(e,rect)"
            @onmousedown="(e) => StartDrag(e, rect)" @onmousedown:stopPropagation>
                <div class="PlateContainer" style="@(GetRotationStyle(rect, zoomLevel)) transform: rotate(@($"{rect.Rotation}deg"))">
                    <img loading="lazy" class="img-test" tabindex="-1" src="@rect.ImageUrl" draggable="false" />
                </div>
            </div>
        }

        @if (alignmentLines.Any())
        {
            @foreach (var line in alignmentLines)
            {
                <div class="alignment-line"
                style="left: @($"{line.X * zoomLevel}px");
                            top: @($"{line.Y * zoomLevel}px");
                            width: @($"{(!line.isVertical ? line.Lenght * zoomLevel : 2)}px");
                            height: @($"{(line.isVertical ? line.Lenght * zoomLevel : 2)}px");" />
            }
        }

        @if (CurrentState == State.Selecting)
        {
            <div class="selection-box"
            style="left: @($"{Math.Min(selectionBoxStartX, selectionBoxEndX)}px");
                        top: @($"{Math.Min(selectionBoxStartY, selectionBoxEndY)}px");
                        width: @($"{Math.Abs(selectionBoxEndX - selectionBoxStartX)}px");
                        height: @($"{Math.Abs(selectionBoxEndY - selectionBoxStartY)}px");" />
        }
    </div>

    <div class="selection-container">
        <input type="text" @bind="searchTerm" @oninput="FilterPlates" placeholder="Search" class="search-box" />
        <div class="selection-items-container">
            <Virtualize Items="@filteredPlates" Context="plate">
                <div class="selection-item" @onclick="() => AddPlate(plate)">
                    <img loading="lazy" src="@plate.ImageUrl" />
                    <span>@plate.Name</span>
                </div>
            </Virtualize>
        </div>
    </div>
</div>

@code {
    private State CurrentState = State.None;
    private const int plateLimit = 100;    
    private const double snapValue = 0.25;
    private double selectionBoxStartX = 0;
    private double selectionBoxStartY = 0;
    private double selectionBoxEndX = 0;
    private double selectionBoxEndY = 0;
    private double gridContainerStartX, gridContainerStartY;
    private List<PlateData> platesData = new List<PlateData>();
    private List<Plate> plates = new List<Plate>();
    private List<Plate> selectedPlates = new List<Plate>();
    private List<Plate> draggingPlates = new List<Plate>();
    private List<Plate> clipboard = new List<Plate>();
    private List<PlateData> filteredPlates = new();
    private string searchTerm = "";
    private double zoomLevel = 5.0; // Zoom level
    private double offsetX = 0;
    private double offsetY = 0;
    private bool wasDragged = false;
    private bool hasLoaded = false;

    private record AlignmentLine(bool isVertical, double X, double Y, double Lenght);
    private List<AlignmentLine> alignmentLines = new();
    private void CalculateAlignmentLines()
    {
        alignmentLines.Clear();

        foreach (var plate in plates)
        {
            if (draggingPlates.Contains(plate)) continue;

            foreach (var draggingPlate in draggingPlates)
            {
                CheckAlignment(plate, draggingPlate, true);
                CheckAlignment(plate, draggingPlate, false);
            }
        }
    }

    private void CheckAlignment(Plate plate, Plate selectedPlate, bool isVertical)
    {
        double plateCenter = isVertical ? plate.X + plate.Width / 2 : plate.Y + plate.Height / 2;
        double draggingCenter = isVertical ? selectedPlate.X + selectedPlate.Width / 2 : selectedPlate.Y + selectedPlate.Height / 2;

        if (IsAligned(plateCenter, draggingCenter))
        {
            AddAlignmentLine(isVertical, plateCenter, plate, selectedPlate); // Middle alignment
        }
        else
        {
            double plateStart = isVertical ? plate.X : plate.Y;
            double plateEnd = isVertical ? plate.X + plate.Width : plate.Y + plate.Height;
            double selectedStart = isVertical ? selectedPlate.X : selectedPlate.Y;
            double selectedEnd = isVertical ? selectedPlate.X + selectedPlate.Width : selectedPlate.Y + selectedPlate.Height;

            TryAddAlignment(isVertical, plate, selectedPlate, plateStart, selectedStart); // Start alignment
            TryAddAlignment(isVertical, plate, selectedPlate, plateEnd, selectedStart); // End to start alignment
            TryAddAlignment(isVertical, plate, selectedPlate, plateStart, selectedEnd); // Start to end alignment
            TryAddAlignment(isVertical, plate, selectedPlate, plateEnd, selectedEnd); // End alignment
        }
    }

    private bool IsAligned(double pos1, double pos2) => Math.Abs(pos1 - pos2) < snapValue;

    private void TryAddAlignment(bool isVertical, Plate plate, Plate selectedPlate, double pos1, double pos2)
    {
        if (IsAligned(pos1, pos2))
        {
            AddAlignmentLine(isVertical, pos1, plate, selectedPlate);
        }
    }

    private void AddAlignmentLine(bool isVertical, double position, Plate plate, Plate selectedPlate)
    {
        alignmentLines.Add(new AlignmentLine(isVertical,
            isVertical ? position : Math.Min(plate.X, selectedPlate.X),
            isVertical ? Math.Min(plate.Y, selectedPlate.Y) : position,
            isVertical
                ? Math.Max(plate.Y + plate.Height, selectedPlate.Y + selectedPlate.Height) - Math.Min(plate.Y, selectedPlate.Y)
                : Math.Max(plate.X + plate.Width, selectedPlate.X + selectedPlate.Width) - Math.Min(plate.X, selectedPlate.X)));
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadPlates();
        Console.WriteLine("Loaded");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JsRuntime.InvokeVoidAsync("myUtils.addZoomPreventingHandler", "grid", "wheel");
        }

        if (firstRender && !hasLoaded)
        {
            await LoadStateFromLocalStorage();
            Console.WriteLine("Loaded");
            hasLoaded = true;
        }
    }

    private async void OnMouseDown(MouseEventArgs e)
    {
        if (e.Button != 0)
        {
            return;
        }

        var scroll = await GetGridScrollData();
        if (scroll == null)
        {
            return;
        }

        // Get the absolute position of the grid container by using the first mouse event
        if (gridContainerStartX == 0 && gridContainerStartY == 0)
        {
            gridContainerStartX = e.ClientX - e.OffsetX;
            gridContainerStartY = e.ClientY - e.OffsetY;
        }

        // Calculate relative start position
        selectionBoxStartX = e.ClientX - gridContainerStartX + scroll.ScrollLeft;
        selectionBoxStartY = e.ClientY - gridContainerStartY + scroll.ScrollTop;
        selectionBoxEndX = selectionBoxStartX;
        selectionBoxEndY = selectionBoxStartY;

        CurrentState = State.Selecting;
    }

    private async void OnMouseMove(MouseEventArgs e)
    {
        switch (CurrentState)
        {
            case State.Dragging:
                DragSelectedPlates(e);
                break;

            case State.Selecting:

                var scroll = await GetGridScrollData();

                if (scroll == null)
                {
                    return;
                }

                selectionBoxEndX = e.ClientX - gridContainerStartX + scroll.ScrollLeft;
                selectionBoxEndY = e.ClientY - gridContainerStartY + scroll.ScrollTop;

                //UpdateSelectedPlatesWithinTheBox();
                break;
        }
    }

    private void OnMouseUp(MouseEventArgs e)
    {
        switch (CurrentState)
        {
            case State.Dragging:
                draggingPlates.Clear();
                alignmentLines.Clear();
                break;

            case State.Selecting:
                UpdateSelectedPlatesWithinTheBox();
                break;
        }

        CurrentState = State.None;

    }

    private void UpdateSelectedPlatesWithinTheBox()
    {
        var selectionRect = new Selection(
            Math.Min(selectionBoxStartX, selectionBoxEndX) / zoomLevel,
            Math.Min(selectionBoxStartY, selectionBoxEndY) / zoomLevel,
            Math.Abs(selectionBoxEndX - selectionBoxStartX) / zoomLevel,
            Math.Abs(selectionBoxEndY - selectionBoxStartY) / zoomLevel
        );

        selectedPlates = plates.Where(plate => IsPlateInSelection(plate, selectionRect)).ToList();
    }

    private bool IsPlateInSelection(Plate plate, Selection selectionRect)
    {
        var plateRect = new Selection(plate.X, plate.Y, plate.Width, plate.Height);
        return selectionRect.IntersectsWith(plateRect);
    }

    private async Task LoadPlates()
    {
        var limitedEdition = new List<PlateData>();
        var lumino = new List<PlateData>();

        try
        {
            var response = await HttpClient.GetFromJsonAsync<LimitedResponse>("https://sapi.displate.com/artworks/limited?miso=US");
            limitedEdition = response.Data.Select(x => new PlateData(DateTime.Parse(x.Edition.StartDate), x.Title, x.Images.Main.Url, x.Edition.Type, x.Images.Main.Width > x.Images.Main.Height)).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load limited editions: {ex.Message}");
        }

        try
        {
            var response = await HttpClient.GetFromJsonAsync<LuminoResponse>("/lumino.json");
            lumino = response.LuminoListings.Data
           .Select(x => new PlateData(x.StartDate, x.Title, x.Image.X2.Replace("460x640", "560x784"), "standard", false))
           .ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load limited editions: {ex.Message}");
        }

        var combinedLimited = limitedEdition.Concat(lumino).OrderByDescending(x => x.StartDate).ToList();

        platesData = combinedLimited;
        filteredPlates = combinedLimited;
    }

    private async Task LoadStateFromLocalStorage()
    {
        var savedPlates = await LocalStorage.GetItemAsync<List<Plate>>("savedPlates");
        if (savedPlates != null)
        {
            plates = savedPlates;
        }
    }

    private async Task<ScrollData?> GetGridScrollData()
    {
        try
        {
            return await JsRuntime.InvokeAsync<ScrollData>("getScrollPosition", "grid");
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        return null;
    }

    private void OnZoom(WheelEventArgs e)
    {
        if (!e.CtrlKey || CurrentState != State.None) return;

        zoomLevel = e.DeltaY > 0 ? Math.Max(zoomLevel - 1, 3) : Math.Min(zoomLevel + 1, 15.0);
    }

    private void AddPlate(PlateData selectedPlate)
    {
        if (plates.Count >= plateLimit)
        {
            return;
        }

        SaveState();
        plates.Add(new Plate(selectedPlate.ImageUrl, selectedPlate.Type, selectedPlate.IsHorizontal));
    }

    private void SelectAPlate(MouseEventArgs e, Plate rect)
    {
        if (wasDragged)
        {
            wasDragged = false;
            return;
        }

        if (e.ShiftKey || e.CtrlKey)
        {
            if (selectedPlates.Contains(rect))
            {
                selectedPlates.Remove(rect);
            }
            else
            {
                selectedPlates.Add(rect);
            }
        }
        else
        {
            selectedPlates.Clear();
            selectedPlates.Add(rect);
        }
    }

    private ScrollData scrollStartDrag = new(0, 0);
    private async void StartDrag(MouseEventArgs e, Plate rect)
    {
        if (e.Button != 0) return;

        CurrentState = State.Dragging;
        draggingPlates.Clear();
        SaveState();
        if (!selectedPlates.Contains(rect))
        {
            if (!e.ShiftKey && !e.CtrlKey)
            {
                selectedPlates.Clear();
                selectedPlates.Add(rect);
            }
            else
            {
                return;
            }
        }

        if (selectedPlates.Contains(rect))
        {
            draggingPlates.AddRange(selectedPlates);
        }
        else
        {
            draggingPlates.Add(rect);
        }

        offsetX = e.ClientX;
        offsetY = e.ClientY;

        var scroll = await GetGridScrollData();

        scrollStartDrag = scroll == null ? new(0, 0) : scroll;
        CalculateAlignmentLines();
    }

    private async void DragSelectedPlates(MouseEventArgs e)
    {
        if (draggingPlates.Count == 0) return;

        var scroll = await GetGridScrollData() ?? new ScrollData(0, 0);
        var scrollX = scroll.ScrollLeft - scrollStartDrag.ScrollLeft;
        var scrollY = scroll.ScrollTop - scrollStartDrag.ScrollTop;
        scrollStartDrag = scroll;

        var dx = e.ClientX - offsetX + scrollX;
        var dy = e.ClientY - offsetY + scrollY;

        if (Math.Abs(dx) > 3 || Math.Abs(dy) > 3)
        {
            var zoomAdjustedX = GetSnappedValue(dx / zoomLevel, snapValue);
            var zoomAdjustedY = GetSnappedValue(dy / zoomLevel, snapValue);

            foreach (var plate in draggingPlates)
            {
                plate.X += zoomAdjustedX;
                plate.Y += zoomAdjustedY;
            }

            offsetX = e.ClientX;
            offsetY = e.ClientY;
            wasDragged = true;

            CalculateAlignmentLines();
        }
    }


    private void RemoveSelectedPlates()
    {
        SaveState();
        foreach (var plate in selectedPlates)
        {
            plates.Remove(plate);
        }

        selectedPlates.Clear();
    }

    private void OnKeyDown(KeyboardEventArgs e)
    {
        if (CurrentState != State.None) return;

        switch (e.Key)
        {
            case "1":
                ArrangePlatesInOneLine();
                break;
            case "Delete":
                RemoveSelectedPlates();
                break;
            case "Escape":
                selectedPlates.Clear();
                draggingPlates.Clear();
                break;
            case "ArrowUp":
                MoveSelectedPlates(0, -snapValue);
                break;
            case "ArrowDown":
                MoveSelectedPlates(0, snapValue);
                break;
            case "ArrowLeft":
                MoveSelectedPlates(-snapValue, 0);
                break;
            case "ArrowRight":
                MoveSelectedPlates(snapValue, 0);
                break;

            case "a" when e.CtrlKey:
                selectedPlates.Clear();
                foreach (var plate in plates)
                {
                    selectedPlates.Add(plate);
                }
                break;
            case "z" when e.CtrlKey:
                Undo();
                break;
            case "y" when e.CtrlKey:
                Redo();
                break;
            case "c" when e.CtrlKey:
                Copy();
                break;
            case "v" when e.CtrlKey:
                Paste();
                break;
            case "r" when e.CtrlKey:
                RotateSelectedPlates();
                break;
        }
    }

    private void MoveSelectedPlates(double dx, double dy)
    {
        SaveState();
        foreach (var plate in selectedPlates)
        {
            plate.X += dx;
            plate.Y += dy;
        }
    }

    private void RotateSelectedPlates()
    {
        SaveState();
        foreach (var plate in selectedPlates)
        {
            plate.Rotate();
        }
    }

    private void ArrangePlatesInOneLine()
    {
        SaveState();
        double currentX = 0; // Starting X position for the first plate
        double fixedY = 0;   // Fixed Y position (you can change this if needed)

        foreach (var plate in selectedPlates)
        {
            plate.X = currentX;
            plate.Y = fixedY;
            currentX += plate.Width; // Add some space between plates
        }
    }

    private void Copy()
    {
        if (selectedPlates.Count == 0) return;

        clipboard = selectedPlates.Select(p => new Plate(p.ImageUrl, p.Type, p.IsHorizontal)
            {
                X = p.X,
                Y = p.Y,
                Rotation = p.Rotation
            }).ToList();
    }

    private void Paste()
    {
        if (clipboard.Count == 0) return;
        if (plates.Count + clipboard.Count > plateLimit) return;

        SaveState();
        selectedPlates.Clear();

        var pastedPlates = new List<Plate>();
        foreach (var p in clipboard)
        {
            double newX = p.X + 2;
            double newY = p.Y + 2;

            while (plates.Any(existing => existing.X == newX && existing.Y == newY))
            {
                newX += 2;
                newY += 2;
            }

            var newPlate = new Plate(p.ImageUrl, p.Type, p.IsHorizontal)
                {
                    X = newX,
                    Y = newY,
                    Rotation = p.Rotation
                };

            plates.Add(newPlate);
            pastedPlates.Add(newPlate);
        }

        selectedPlates.AddRange(pastedPlates);
    }

    private void SaveState() => HistoryService.SaveState(plates);

    private void Undo() => HistoryService.Undo(plates);

    private void Redo() => HistoryService.Redo(plates); 

    private void FilterPlates(ChangeEventArgs e)
    {
        searchTerm = e.Value?.ToString() ?? "";
        filteredPlates = platesData
            .Where(p => p.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase))
            .ToList();
    }

    private double GetSnappedValue(double value, double snapValue)
    {
        return Math.Round(value / snapValue) * snapValue;
    }

    private string GetRotationStyle(Plate plate, double zoomLevel)
    {
        var isSideways = plate.Rotation == 90 || plate.Rotation == 270;

        var styleWidth = isSideways ? plate.Height : plate.Width;
        var styleHeight = isSideways ? plate.Width : plate.Height;

        return $"""height:{styleHeight * zoomLevel}px; width:{styleWidth * zoomLevel}px;""";
    }
}

<script>
    function getScrollPosition(elementId) {
        const element = document.getElementById(elementId);

        return {
            scrollTop: element.scrollTop,
            scrollLeft: element.scrollLeft
        };
    }

    window.myUtils = {
        addZoomPreventingHandler: function (elementId, eventName) {
            const element = document.getElementById(elementId);
            if (element) {
                element.addEventListener(eventName, e => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                    }
                }, { passive: false });
            }
        }
    };
</script>